# 🏬 EZPZ
![Frame 3](https://github.com/user-attachments/assets/9db7d2ef-fa15-402b-a514-5e0ef5e414d7)

**EZPZ**는 `'Easy Popup Zone'`의 약자로, 사용자들에게 간편하고 직관적인 팝업 스토어 경험을 제공하는 것을 목표로 합니다. EZPZ는 최신 팝업 트렌드를 한눈에 볼 수 있는 허브 역할을 하며, 사용자가 쉽고 빠르게 예약하고 원하는 굿즈를 구매할 수 있도록 돕습니다. EZPZ를 통해 팝업 스토어의 모든 과정을 손쉽게 관리하고 즐길 수 있는 최적의 공간을 제공하여, 트렌드에 민감한 MZ 세대의 기대를 충족시키고자 합니다.
</br></br>

## ✔️ ERD
![Copy of ezpz (최종) (1)](https://github.com/user-attachments/assets/56b9f919-304d-4c42-8641-34949d46fa30)

## ✔️ 요구사항 명세
https://docs.google.com/spreadsheets/d/1_3SPLxWsbA3cSi7pJJ3N0nBEA1QJgEhzCbwG_eMMU6c/edit?usp=sharing
</br></br>


## ✔️ API 명세
https://docs.google.com/spreadsheets/d/1idzqXzU3zV-MfIImZvRcLJuWeOOjaQd8rtfax7csXdI/edit?usp=sharing
</br></br>

## ✔️ 서비스 아키텍처
![인프라구성도 drawio](https://github.com/user-attachments/assets/8f3117ea-06b0-459b-875b-551671996083)

## ✔️ GitHub 주소
### Backend
- User : https://github.com/NBCAMP-EZPZ/EZPZ-User
- Host : https://github.com/NBCAMP-EZPZ/EZPZ-Host
- Admin : https://github.com/NBCAMP-EZPZ/EZPZ-Admin

### FrontEnd
- User : https://github.com/NBCAMP-EZPZ/EZPZ-User-Front
- Host : https://github.com/NBCAMP-EZPZ/EZPZ-Host-Front
- Admin : https://github.com/NBCAMP-EZPZ/EZPZ-Admin-Front

</br></br>

## ✔️ 주요 기술
|기술|사용처|
|:-:|:-:|
|AWS S3|이미지 파일 저장소 및 스크립트 파일 저장소|
|AWS EC2|프로젝트 배포를 위해서 클라우드 컴퓨팅 서비스|
|AWS ElastiCache|Redis를 사용하여, Refresh 토큰 저장, 캐시 처리, 분산락 처리|
|AWS RDS|MySQL을 사용하며, 자동화된 관리와 백업을 통해 운영 부담 줄임|
|GitHub Action|자동화된 파이프라인을 통해서 코드 변경과 배포를 원활하게 하기 위해서 CI/CD 적용|
|Docker|JAVA 파일을 빌드 및 배포|
|AWS ECR|Docker 이미지의 안전한 관리를 지원|
|AWS CodeDeploy|EC2 인스턴스, ECS, serverless lambda function 등 여러 서비스 애플리케이션 배포를 자동화|
|AWS Route53|외부의 프론트엔드 어플리케이션으로 라우팅 및 ALB 인프라로 요청 전달|
|AWS ALB|어플리케이션의 트래픽을 분산, 클라이언트 요청에 따른 서버 라우팅|
|Spring Batch|대량의 통계 데이터 처리|
|Netlify|프론트엔드 어플리케이션 배포|
|nGrinder|Traffic을 던져 성능 테스트|

</br></br>

## ✔️ 주요 기능
### 👤 User
- 팝업 목록 조회
- 팝업 상세 조회
- 팝업 굿즈 목록 조회
- 팝업 굿즈 상세 조회
- 굿즈 장바구니 담기
- 굿즈 주문
- 팝업 오프라인 예약 목록 조회
- 팝업 오프라인 예약 상세 조회
- 팝업 오프라인 예약 등록
- 팝업, 굿즈 좋아요
- 좋아요 목록 조회
- 쿠폰 목록 조회
- 쿠폰 선착순 다운로드

### 🏢 Host
- 팝업 목록 조회
- 팝업 등록
- 팝업 굿즈 등록
- 팝업 굿즈 판매량 통계 조회
- 팝업 오프라인 예약 목록 조회
- 팝업 오프라인 예약 상세 조회

### 🧑‍💻 Admin
- 팝업 목록 조회
- 신규 팝업 심사
- 쿠폰 발행

</br></br>

## ✔️ 기술적 의사 선택
<details>
  <summary>1. 동시성 제어</summary>
  
  > 도입 배경

  데이터베이스 접근을 필요로 하는 요청(예: 선착순 쿠폰 다운로드)들이 동시에 들어올 때 트랜잭션 단위로 데이터베이스에 접근하게 되는데, 이를 동시적으로 모두 허용해주면 레이스 컨디션이 발생하여 데이터베이스의 일관성과 무결성이 깨지게 됩니다. 이를 방지하기 위해 동시성 제어를 통해 데이터베이스를 보호해야 했습니다.

  > 선택지

  **낙관적 락**은 데이터 충돌이 발생했을 때 이를 해결하기 위한 추가적인 로직(재시도 로직)이 필요하고, 충돌이 자주 발생하는 시스템에서는 이를 해결하기 위한 추가적인 시간이 필요합니다. </br>
  **비관적 락**은 동시 접속자가 많은 환경에서 락 대기 시간으로 인해 성능에 영향을 줄 수 있고, 다수의 트랜잭션이 서로 다른 순서로 여러 데이터에 락을 요청하면 데드락이 발생할 수 있습니다.</br>
  **분산락**은 서버 분산 환경에서도 프로세스들의 원자적 연산이 가능하지만, 락 서비스를 설정하고 관리하는 것이 복잡합니다.

  > 의사결정

  서버 분산 환경에서도 일관성을 유지해야 하기 때문에 분산락을 사용하기로 결정했습니다.

</details>
<details>
  <summary>2. 분산락 구현</summary>
  
  > 도입 배경

  동시성 제어를 하는 방법으로 분산락을 이용하기로 결정했기 때문에 분산락을 구현해야 했습니다.

  > 선택지

  **Zookeeper**는 분산 시스템에서 높은 일관성과 동기화 기능을 제공합니다. 데이터가 디스크에 저장되므로 시스템 장애 시에도 데이터 일관성을 유지할 수 있고, 단순한 락 외에도 분산 환경에서 필요한 다양한 코디네이션 기능을 제공합니다. 하지만 클러스터를 설정하고 관리하는 것이 복잡하고, 네트워크 지연이나 클러스터의 크기에 따라 성능이 저하될 수 있습니다. </br>

**MySQL**은 기존의 데이터베이스 인프라를 활용하여 추가적인 비용 없이 락 기능을 구현할 수 있습니다. SQL 쿼리로 간단히 락을 구현할 수 있으며, 데이터베이스 트랜잭션을 활용하여 락을 처리할 수 있습니다. 하지만 성능이 저하될 수 있으며, 여러 트랜잭션이 동시에 락을 요청할 때 경합이 발생할 수 있습니다. </br>

**Redis**는 인메모리 기반의 데이터 저장소로 매우 빠른 성능을 제공하며, TTL(만료 시간)을 설정하여 자동으로 락을 해제할 수 있습니다. 또한 Redis의 간단한 API를 사용하여 분산락을 쉽게 관리할 수 있습니다. 하지만 Redis 인스턴스가 장애를 겪으면 락 기능에 영향을 줄 수 있으며, 데이터가 손실될 수 있습니다.

  > 의사결정

  락의 성능이 좋고, Redis 라이브러리에서 다양한 분산락 구현체들을 지원하기 때문에 손쉽게 사용이 가능할 뿐만 아니라, 캐시 처리와 토큰 저장 등에도 Redis가 같이 쓰이기 때문에 Redis를 이용하여 분산락을 구현하기로 결정했습니다.</details>
<details>
  <summary>3. Redisson</summary>
  
  > 도입 배경

  분산락을 구현하는 방법으로 Redis을 이용하기로 결정했었습니다. Redis를 이용한 분산락을 구현하기 위해서 구현체를 선택해야 했습니다.
  
> 선택지

  **Jedis**는 Java에서 Redis와 상호작용하기 위한 기본적인 클라이언트 라이브러리입니다. 사용이 간편하고 Redis 명령어와 직접 상호작용할 수 있어 구현이 용이합니다. 하지만 Redis 클러스터와 같은 고급 기능을 사용하려면 추가 설정이 필요할 수 있고, 기본적으로 동기 API를 제공하기 때문에, 비동기 작업은 별도의 라이브러리가 필요할 수 있습니다.</br>

  **Lettuce**은 spring-data-redis의 기본 구현체로, 비동기, 반응형(reactive) 및 클러스터 지원을 제공합니다. 또한 멀티플렉싱을 지원하여 여러 Redis 커넥션을 효율적으로 관리할 수 있습니다. 이를 통해 Jedis에 비해 몇배 이상의 성능과 하드웨어 자원 절약이 가능합니다. 하지만 Spin Lock을 사용하여 반복적으로 락 획득을 시도하기 때문에 레디스에 많은 부하가 발생합니다. 또한 락에 대한 타임아웃이 없어, 락 해제 호출을 하지 못한 경우 Dead Lock을 유발할 수 있습니다.</br>

  **Redisson**는 pub/sub 방식을 사용하여 락을 당장 획득할 수 없으면 대기하고, 락이 획득 가능할 경우 Redis에서 클라이언트로 획득 가능함을 알려줍니다. 또한 락의 lease time 설정이 가능하기 때문에 설정된 lease time이 지난 경우 자동으로 Lock의 소유권을 회수하여 Dead Lock을 방지할 수 있습니다.</br>

  > 의사결정

  Pub/Sub 방식으로 동작해 Lettuce에 비해 Redis에 부하가 덜 가는 Redisson을 사용하기로 결정했습니다.
</details>
<details>
  <summary>4. ElastiCache</summary>
  
  > 도입 배경

  문자열, 해시, 리스트, 세트 등 다양한 데이터 구조를 지원하는 Redis를 사용하여 `RefreshToken, 캐싱 처리, 분산락 처리`를 해야 했습니다  

> 자체 관리 Redis VS ElastiCache

  자체 관리 Redis는 서버 설정, 모니터링, 업그레이드 등을 직접 관리해야 합니다. 이는 많은 시간과 자원을 소모합지만, ElastiCache는 이러한 작업을 자동으로 처리하여 운영 부담을 줄여줍니다. 그리고, 자체 관리 환경에서는 수요에 맞게 수동으로 서버를 추가하고 설정해야 하지만, ElastiCache는 자동 확장 기능을 제공하여, 필요에 따라 자동으로 리소스를 확장하거나 축소할 수 있습니다.

  > 의사결정

이에 따라 오토 스케일링이 가능하고, 운영 부담이 적은 ElastiCache를 선택하게 되었습니다.
</details>
<details>
  <summary>5. GitHub Action</summary>
  
  > 도입 배경

  반복적인 일들을 처리하고 자동화된 파이프라인을 통해서 코드 변경과 배포를 원활하게 하기 위해 CI/CD 를 구현해야 했습니다.

  > Jenkins VS Github Action

  `Jenkins`는 다양한 플러그인을 통해 거의 모든 CI/CD 시나리오를 지원하고, 복잡한 파이프라인 설정 및 사용자 정의가 가능하다는 장점이 있지만, 초기 설정과 유지 보수가 복잡하고 사용자가 직접 서버를 관리해야 한다는 단점이 있습니다.

`GitHub Action`은 GitHub와 깊이 통합되어 있어, GitHub 리포지토리 내에서 바로 CI/CD 파이프라인을 설정하고 관리할 수 있고, 서버 관리가 필요하지 않다는 장점이 있지만, 대규모 파이프라인을 구현하는 데는 제한이 있다는 단점이 있습니다.

  > 의사결정

  저희 팀은 아직 프로젝트가 크지 않기 때문에 대규모 파이프라인을 구현하는 것보다는, GitHub과의 직접적인 통합을 통해 워크플로우를 간소화 하는 것이 좋을 것이라고 판단하여 GitHub Action을 선택하였습니다.
</details>
<details>
  <summary>6. Docker, ECR, CodeDeploy</summary>
  
  > 선택 이유

**Docker**</br>
Docker를 사용하면 응용 프로그램을 서로 다른 환경에서도 일관되게 실행할 수 있고, 개발 환경과 운영 환경 사이의 차이로 인한 문제를 줄일 수 있다는 점에 Docker를 사용한 컨테이너 기반 배포 방식을 사용하기로 결정 하였습니다.

**AWS ECR**</br>
Docker Hub에도 프라이빗한 레포지토리가 있지만 프로젝트의 인프라를 AWS를 이용해서 구축하기 때문에 연계부분의 이점으로 도입하였습니다.
- Docker 이미지의 안전한 관리를 지원
- AWS 인프라와의 긴밀한 통합을 통해 우수한 보안성, 관리 용이성 및 확장성 제공
- IAM을 통한 세분화된 접근 권한 및 보안 관리 가능

**AWS CodeDeploy**</br>
CodeDeploy를 통해 배포 진행 상황 모니터링하고 배포 자동화를 위해 선택하게 되었습니다.
</details>
<details>
  <summary>7. Batch Scheduler</summary>
  
  > 도입 배경

  - 팝업 스토어의 **일별 매출, 그리고 통합 매출**을 매번 계산하는 것이 아닌, 따로 테이블을 만들어 관리하고 업데이트 해야 할 필요성을 느꼈습니다.
  - 팝업 스토어의 **진행 종료일**과, 오프라인 예약의 **진행일**이 지나면 상태를 자동으로 변경시켜 주어야 할 필요성을 느꼈습니다.

  > Batch Scheduler VS Quartz Scheduler

**Batch Scheduler**</br>
`대규모 데이터를 일괄 처리하는 데 최적화`되어 있습니다. 이는 대량의 데이터를 동시에 처리해야 하는 경우 특히 중요하며, 다른 스케줄러들에 비해 안정적이고 효율적인 성능을 제공합니다. 특정 환경에 맞게 커스터마이징이 용이하며, 기존의 시스템이나 다른 도구들과의 통합이 용이합니다. 이는 `기존 워크플로우에 Batch Scheduler를 무리 없이 도입`할 수 있게 해줍니다. </br>
하지만, 확장성 측면에서 한계가 있습니다. 특히 분산 처리나 클러스터링이 필요한 경우에는 추가적인 솔루션이 필요할 수 있으며,  `Spring에 의존`하기 때문에, Spring을 사용하지 않는 프로젝트에서는 사용이 어렵거나 불편할 수 있습니다.

**Quartz Scheduler**</br>
Quartz는 `자바 기반의 강력한 스케줄링 라이브러리`로, 복잡한 스케줄링 작업과 다양한 트리거 옵션을 통해 다양한 시나리오에 맞춤형 스케줄링을 구현할 수 있습니다. Persistent Job Store를 통해 작업 스케줄링을 영구 저장하고, 시스템 재시작 시에도 작업이 유지됩니다. </br>
하지만, `유연성이 높은 만큼 설정이 복잡`할 수 있으며, 특히 복잡한 스케줄링을 구성하려면 러닝 커브가 필요합니다. 또한, 다수의 작업을 메모리에 유지하기 때문에 메모리 사용량이 높아질 수 있으며, 대규모 작업을 처리할 때 시스템 리소스에 부담이 될 수 있습니다.

  > 의사결정

  현재 프로젝트가 Spring 기반의 프로젝트이며, 통계 데이터를 만들고 자동화 작업을 할 때에 서버 간 데이터 공유가 필요하지 않기 때문에 Quartz 까지는 사용할 필요가 없다고 생각하여 **Batch Scheduler**를 통해 통계 작업을 처리하도록 결정하였습니다.
</details>
